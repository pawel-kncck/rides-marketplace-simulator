<!DOCTYPE html>
<html>
<head>
<title>6_platform_and_matching_logic.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="developer-guide-platform--matching-logic">Developer Guide: Platform &amp; Matching Logic</h1>
<p>This document provides an in-depth analysis of the platform's &quot;backend&quot; logic. The primary goal is to explain how the simulation connects supply (drivers) with demand (riders). We will see that the <code>Platform</code> class is a lightweight container, while the core, critical logic is housed within the <code>Matcher</code> class.</p>
<p>Understanding the <code>Matcher</code> is essential, as its efficiency and logic directly determine the marketplace's liquidity and user experience.</p>
<hr>
<h2 id="1-the-platform-class-a-simple-container">1. The <code>Platform</code> Class: A Simple Container</h2>
<p>The <code>Platform</code> class, defined in <code>simulator/platform/platform.py</code>, has a very straightforward role: it acts as a container that represents a single ride-hailing company (e.g., &quot;Platform A&quot;).</p>
<p>Its <code>__init__</code> method simply stores the <code>platform_id</code> and, most importantly, an instance of the <code>Matcher</code> class, which is created and passed in from <code>main.py</code>.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># in simulator/platform/platform.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Platform</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, platform_id: str, matcher: Matcher)</span>:</span>
        self.platform_id = platform_id
        self.matcher = matcher
</div></code></pre>
<p>All complex work is delegated to the <code>matcher</code> object.</p>
<hr>
<h2 id="2-the-matcher-deep-dive-the-heart-of-the-platform">2. The <code>Matcher</code> Deep Dive: The Heart of the Platform</h2>
<p>The <code>Matcher</code> class in <code>simulator/platform/matcher.py</code> contains the algorithm for connecting a rider who is <code>SEARCHING</code> with an available driver. The entire process is orchestrated by the <code>process_order</code> method. Let's walk through its execution step-by-step.</p>
<h3 id="step-1-find-nearby-idle-drivers"><strong>Step 1: Find Nearby Idle Drivers</strong></h3>
<p>The process begins when <code>market.py</code> calls <code>matcher.process_order</code> for a specific rider. The very first action is to find a pool of potential candidates using the <code>find_nearest_idle_drivers</code> method.</p>
<p>This helper method performs two key actions:</p>
<ol>
<li>It gets the rider's cell ID from the <code>HexGrid</code>.</li>
<li>It retrieves all agents in that cell and then filters that list to return only <code>DriverAgent</code> instances that are in the <code>IDLE</code> state.</li>
</ol>
<!-- end list -->
<pre class="hljs"><code><div><span class="hljs-comment"># in simulator/platform/matcher.py</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_nearest_idle_drivers</span><span class="hljs-params">(self, rider: RiderAgent)</span> -&gt; List[DriverAgent]:</span>
    rider_cell = self.grid.get_cell_id(rider.location)
    <span class="hljs-comment"># ...</span>
    drivers_in_cell = self.grid.get_agents_in_cell(rider_cell)
    idle_drivers = [d <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> drivers_in_cell <span class="hljs-keyword">if</span> isinstance(d, DriverAgent) <span class="hljs-keyword">and</span> d.current_state == DriverState.IDLE]
    <span class="hljs-keyword">return</span> idle_drivers
</div></code></pre>
<p>The result is a list called <code>idle_drivers</code>, which the <code>Matcher</code> will now attempt to contact one by one.</p>
<h3 id="step-2-the-%22order-try%22-loop"><strong>Step 2: The &quot;Order Try&quot; Loop</strong></h3>
<p>The <code>Matcher</code> iterates through the list of <code>idle_drivers</code>. Each iteration represents an &quot;order try&quot;—a single offer being sent to a single driver.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># in simulator/platform/matcher.py, inside process_order</span>
idle_drivers = self.find_nearest_idle_drivers(rider)

<span class="hljs-keyword">for</span> i, driver <span class="hljs-keyword">in</span> enumerate(idle_drivers):
    <span class="hljs-comment"># ... logic for each driver</span>
</div></code></pre>
<h3 id="step-3-driver-evaluation-and-acceptance"><strong>Step 3: Driver Evaluation and Acceptance</strong></h3>
<p>Inside the loop, for each driver, a two-step evaluation occurs:</p>
<ol>
<li>
<p><strong>Check Max Tries</strong>: First, the <code>Matcher</code> checks if it has already tried too many drivers for this one ride request. This prevents a single ride request from consuming excessive system resources or bothering too many drivers. If the limit is reached, the process is aborted for this ride.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># in simulator/platform/matcher.py</span>
<span class="hljs-keyword">if</span> i &gt;= self.max_order_tries:
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-string">"UNFULFILLED_MAX_TRIES"</span>
</div></code></pre>
</li>
<li>
<p><strong>Calculate Profitability and Decide</strong>: The <code>Matcher</code> calculates the <code>profitability_score</code> using the logic defined in <code>agents/driver/logic.py</code>. The decision is then made based on a simple threshold: if the score is positive, the driver accepts.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># in simulator/platform/matcher.py</span>
eta_to_rider = <span class="hljs-number">5</span> <span class="hljs-comment"># Simplified ETA</span>
profitability_score = calculate_profitability_score(driver, fare, eta_to_rider)

<span class="hljs-comment"># Simplified acceptance logic</span>
<span class="hljs-keyword">if</span> profitability_score &gt; <span class="hljs-number">0</span>:
    <span class="hljs-comment"># ... SUCCESS!</span>
</div></code></pre>
</li>
</ol>
<h3 id="step-4-handling-the-outcome"><strong>Step 4: Handling the Outcome</strong></h3>
<p>The <code>process_order</code> method has three possible final outcomes:</p>
<ol>
<li>
<p><strong><code>MATCH_SUCCESSFUL</code></strong>: If a driver's <code>profitability_score</code> is greater than 0, the match is successful. The states of both agents are updated, and the function immediately returns the <code>driver</code> object and the success status. The loop is broken, and no further drivers are contacted.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># in simulator/platform/matcher.py</span>
<span class="hljs-keyword">if</span> profitability_score &gt; <span class="hljs-number">0</span>:
    driver.current_state = DriverState.DRIVING_TO_RIDER
    rider.current_state = RiderState.ORDERED
    <span class="hljs-keyword">return</span> driver, <span class="hljs-string">"MATCH_SUCCESSFUL"</span>
</div></code></pre>
</li>
<li>
<p><strong><code>UNFULFILLED_MAX_TRIES</code></strong>: As shown in Step 3, if the loop proceeds through more drivers than <code>max_order_tries</code>, it aborts and returns this status.</p>
</li>
<li>
<p><strong><code>UNFULFILLED_NO_DRIVERS</code></strong>: If the <code>for</code> loop completes—meaning every idle driver in the area was offered the ride and rejected it (or there were no idle drivers to begin with)—the function concludes that the order cannot be fulfilled.</p>
<pre class="hljs"><code><div><span class="hljs-comment"># in simulator/platform/matcher.py</span>
<span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-string">"UNFULFILLED_NO_DRIVERS"</span>
</div></code></pre>
</li>
</ol>
<hr>
<h2 id="3-analysis-and-potential-logical-flaws">3. Analysis and Potential Logical Flaws</h2>
<p>The current <code>Matcher</code> implementation is functional but contains several important simplifications that are ripe for future development:</p>
<ol>
<li><strong>Simplistic Proximity Search</strong>: The <code>find_nearest_idle_drivers</code> method only searches within the rider's current grid cell. A rider near the edge of a cell might be closer to a driver in an adjacent cell, but that driver will never be considered. A more realistic approach would search in a &quot;spiral&quot; pattern out from the rider's cell.</li>
<li><strong>Hardcoded and Unrealistic ETA</strong>: The <code>eta_to_rider</code> is hardcoded to a value of <code>5</code>. This is a major simplification. A high-fidelity model would calculate this based on the actual distance between the driver and rider, potentially factoring in average travel speeds.</li>
<li><strong>No Batching or Global Optimization</strong>: The matcher is myopic. It processes orders one by one as they arrive. More advanced dispatch systems might &quot;batch&quot; several nearby requests and solve for the optimal assignment of drivers to riders to maximize overall marketplace efficiency.</li>
<li><strong>Sequential Dispatch</strong>: The matcher offers the ride to drivers one at a time. Many real-world systems use a &quot;broadcast&quot; model where the ride is offered to several of the nearest drivers simultaneously, and the first to accept gets it. The current sequential model simplifies the logic but may be less realistic.</li>
</ol>

</body>
</html>
